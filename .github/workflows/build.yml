name: Upload Releases

permissions:
  contents: write
  actions: read

on:
  workflow_dispatch:
  schedule:
    # Run daily at 2 AM UTC to check for new builds
    - cron: '0 2 * * *'

jobs:
  upload-releases:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Latest Completed Build
        id: get-build
        run: |
          # Get the latest completed workflow run for build.yml
          WORKFLOW_ID=$(gh api repos/${{ github.repository }}/actions/workflows \
            --jq '.workflows[] | select(.name == "Build Apps") | .id')
          
          LATEST_RUN=$(gh api repos/${{ github.repository }}/actions/workflows/${WORKFLOW_ID}/runs \
            --jq '.workflow_runs[] | select(.status == "completed" and .conclusion == "success") | .id' \
            | head -n 1)
          
          if [ -z "$LATEST_RUN" ]; then
            echo "No completed successful runs found"
            exit 1
          fi
          
          echo "Latest completed run ID: $LATEST_RUN"
          echo "run_id=$LATEST_RUN" >> $GITHUB_OUTPUT
          
          # Get run details for release info
          RUN_INFO=$(gh api repos/${{ github.repository }}/actions/runs/${LATEST_RUN})
          RUN_DATE=$(echo "$RUN_INFO" | jq -r '.created_at' | cut -d'T' -f1)
          RUN_SHA=$(echo "$RUN_INFO" | jq -r '.head_sha' | cut -c1-7)
          
          echo "run_date=$RUN_DATE" >> $GITHUB_OUTPUT
          echo "run_sha=$RUN_SHA" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release Directory Structure
        run: |
          mkdir -p releases
          cd releases
          
          # Create platform-specific directories
          mkdir -p electron/{windows,linux,macos}
          mkdir -p native/{windows,linux}
          mkdir -p native-gtk/{windows,linux}
          mkdir -p tauri/{windows,linux}
          mkdir -p ios

      - name: Download and Extract Artifacts
        run: |
          cd releases
          
          # Download all artifacts from the latest build
          gh run download ${{ steps.get-build.outputs.run_id }} \
            --repo ${{ github.repository }}
          
          echo "Downloaded artifacts:"
          ls -la
          
          # Extract and organize artifacts
          
          # Electron builds
          if [ -d "googleballs-desktop-windows-latest_electron" ]; then
            cp -r googleballs-desktop-windows-latest_electron/* electron/windows/
            rm -rf googleballs-desktop-windows-latest_electron
          fi
          
          if [ -d "googleballs-desktop-ubuntu-latest_electron" ]; then
            cp -r googleballs-desktop-ubuntu-latest_electron/* electron/linux/
            rm -rf googleballs-desktop-ubuntu-latest_electron
          fi
          
          if [ -d "googleballs-desktop-macos-latest_electron" ]; then
            cp -r googleballs-desktop-macos-latest_electron/* electron/macos/
            rm -rf googleballs-desktop-macos-latest_electron
          fi
          
          # Native builds
          if [ -d "native-windows-latest_native" ]; then
            cp -r native-windows-latest_native/* native/windows/
            rm -rf native-windows-latest_native
          fi
          
          if [ -d "native-ubuntu-latest_native" ]; then
            cp -r native-ubuntu-latest_native/* native/linux/
            rm -rf native-ubuntu-latest_native
          fi
          
          # Native GTK builds
          if [ -d "native-gtk-windows-latest_native" ]; then
            cp -r native-gtk-windows-latest_native/* native-gtk/windows/
            rm -rf native-gtk-windows-latest_native
          fi
          
          if [ -d "native-gtk-ubuntu-latest_native" ]; then
            cp -r native-gtk-ubuntu-latest_native/* native-gtk/linux/
            rm -rf native-gtk-ubuntu-latest_native
          fi
          
          # Tauri builds
          if [ -d "tauri-windows-latest_tauri" ]; then
            cp -r tauri-windows-latest_tauri/* tauri/windows/
            rm -rf tauri-windows-latest_tauri
          fi
          
          if [ -d "tauri-ubuntu-latest_tauri" ]; then
            cp -r tauri-ubuntu-latest_tauri/* tauri/linux/
            rm -rf tauri-ubuntu-latest_tauri
          fi
          
          # iOS builds
          if [ -d "ios-app_ios" ]; then
            cp -r ios-app_ios/* ios/
            rm -rf ios-app_ios
          fi
          
          echo "Final directory structure:"
          find . -type f | head -20
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate File Information
        id: file-info
        run: |
          cd releases
          
          # Function to get file info
          get_file_info() {
            local dir="$1"
            local platform="$2"
            local type="$3"
            
            if [ -d "$dir" ] && [ "$(ls -A "$dir" 2>/dev/null)" ]; then
              # Find the main executable/installer file
              local main_file=""
              local size=""
              local sha256=""
              
              # Look for different file types based on platform and type
              case "$platform-$type" in
                "windows-electron")
                  main_file=$(find "$dir" -name "*.exe" -o -name "*.msi" | head -1)
                  ;;
                "linux-electron")
                  main_file=$(find "$dir" -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" | head -1)
                  ;;
                "macos-electron")
                  main_file=$(find "$dir" -name "*.dmg" -o -name "*.pkg" | head -1)
                  ;;
                "windows-tauri")
                  main_file=$(find "$dir" -name "*.exe" -o -name "*.msi" | head -1)
                  ;;
                "linux-tauri")
                  main_file=$(find "$dir" -name "*.AppImage" -o -name "*.deb" | head -1)
                  ;;
                "windows-native"*|"linux-native"*)
                  main_file=$(find "$dir" -name "*.exe" -o -name "*desktop*" -o -name "googleballs*" | head -1)
                  ;;
                "ios")
                  main_file=$(find "$dir" -name "*.ipa" | head -1)
                  ;;
              esac
              
              if [ -n "$main_file" ] && [ -f "$main_file" ]; then
                size=$(du -h "$main_file" | cut -f1)
                sha256=$(sha256sum "$main_file" | cut -d' ' -f1)
                echo "${platform}-${type}|$(basename "$main_file")|${size}|${sha256}"
              fi
            fi
          }
          
          # Generate file information
          {
            get_file_info "electron/windows" "windows" "electron"
            get_file_info "electron/linux" "linux" "electron"
            get_file_info "electron/macos" "macos" "electron"
            get_file_info "native/windows" "windows" "native"
            get_file_info "native/linux" "linux" "native"
            get_file_info "native-gtk/windows" "windows" "native-gtk"
            get_file_info "native-gtk/linux" "linux" "native-gtk"
            get_file_info "tauri/windows" "windows" "tauri"
            get_file_info "tauri/linux" "linux" "tauri"
            get_file_info "ios" "ios" "ios"
          } | grep -v "^$" > file_info.txt
          
          echo "Generated file info:"
          cat file_info.txt

      - name: Create Download Table
        run: |
          cd releases
          
          cat > README.md << 'EOF'
          # Google Balls - Downloads
          
          **Build Date:** ${{ steps.get-build.outputs.run_date }}  
          **Commit:** ${{ steps.get-build.outputs.run_sha }}  
          **Build Run:** [#${{ steps.get-build.outputs.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ steps.get-build.outputs.run_id }})
          
          ## Download Links
          
          | Platform | Type | File | Size | SHA256 |
          |----------|------|------|------|--------|
          EOF
          
          # Process file info and add to table
          while IFS='|' read -r platform filename size sha256; do
            # Format platform name
            case "$platform" in
              "windows-electron") platform_name="Windows" ; type_name="Electron" ;;
              "linux-electron") platform_name="Linux" ; type_name="Electron" ;;
              "macos-electron") platform_name="macOS" ; type_name="Electron" ;;
              "windows-native") platform_name="Windows" ; type_name="Native" ;;
              "linux-native") platform_name="Linux" ; type_name="Native" ;;
              "windows-native-gtk") platform_name="Windows" ; type_name="Native GTK" ;;
              "linux-native-gtk") platform_name="Linux" ; type_name="Native GTK" ;;
              "windows-tauri") platform_name="Windows" ; type_name="Tauri" ;;
              "linux-tauri") platform_name="Linux" ; type_name="Tauri" ;;
              "ios-ios") platform_name="iOS" ; type_name="Native" ;;
              *) platform_name="$platform" ; type_name="Unknown" ;;
            esac
            
            # Create download link (relative path)
            download_path=""
            case "$platform" in
              "windows-electron") download_path="electron/windows/$filename" ;;
              "linux-electron") download_path="electron/linux/$filename" ;;
              "macos-electron") download_path="electron/macos/$filename" ;;
              "windows-native") download_path="native/windows/$filename" ;;
              "linux-native") download_path="native/linux/$filename" ;;
              "windows-native-gtk") download_path="native-gtk/windows/$filename" ;;
              "linux-native-gtk") download_path="native-gtk/linux/$filename" ;;
              "windows-tauri") download_path="tauri/windows/$filename" ;;
              "linux-tauri") download_path="tauri/linux/$filename" ;;
              "ios-ios") download_path="ios/$filename" ;;
            esac
            
            # Add row to table
            echo "| $platform_name | $type_name | [$filename]($download_path) | $size | \`$sha256\` |" >> README.md
            
          done < file_info.txt
          
          cat >> README.md << 'EOF'
          
          ## Installation Instructions
          
          ### Electron (Recommended)
          - **Windows**: Download and run the `.exe` installer
          - **Linux**: Download the `.AppImage` file, make it executable, and run
          - **macOS**: Download and open the `.dmg` file
          
          ### Native
          - **Windows**: Download and run the `.exe` file
          - **Linux**: Download the executable and run with `./googleballs-desktop`
          
          ### Native GTK
          - **Windows**: Download, extract, and run the included executable
          - **Linux**: Download, extract, and run using the included launch script: `./launch.sh`
          
          ### Tauri
          - **Windows**: Download and run the `.exe` installer
          - **Linux**: Download the `.AppImage` file, make it executable, and run
          
          ### iOS
          - **iOS**: Download the `.ipa` file and install using a tool like AltStore or similar
          
          ## Build Information
          
          This release was automatically generated from the latest successful build.
          All binaries are unsigned and may trigger security warnings on some systems.
          
          For the latest source code, visit: [https://github.com/${{ github.repository }}](https://github.com/${{ github.repository }})
          EOF
          
          echo "Generated README.md:"
          cat README.md

      - name: Create Release Archive
        run: |
          cd releases
          
          # Create a comprehensive release archive
          tar -czf "googleballs-all-platforms-${{ steps.get-build.outputs.run_date }}-${{ steps.get-build.outputs.run_sha }}.tar.gz" \
            --exclude="*.tar.gz" .
          
          echo "Created release archive:"
          ls -lah *.tar.gz

      - name: Upload to Release
        run: |
          cd releases
          
          # Create or update a release
          RELEASE_TAG="nightly-${{ steps.get-build.outputs.run_date }}"
          RELEASE_NAME="Nightly Build - ${{ steps.get-build.outputs.run_date }}"
          
          # Check if release already exists
          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            echo "Release $RELEASE_TAG already exists, deleting..."
            gh release delete "$RELEASE_TAG" --yes
          fi
          
          # Create new release
          gh release create "$RELEASE_TAG" \
            --title "$RELEASE_NAME" \
            --notes-file README.md \
            --prerelease
          
          # Upload the comprehensive archive
          gh release upload "$RELEASE_TAG" *.tar.gz
          
          # Upload individual platform files
          find . -name "*.exe" -o -name "*.msi" -o -name "*.dmg" -o -name "*.pkg" \
               -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" \
               -o -name "*.ipa" | while read file; do
            if [ -f "$file" ]; then
              gh release upload "$RELEASE_TAG" "$file"
            fi
          done
          
          echo "Release created: https://github.com/${{ github.repository }}/releases/tag/$RELEASE_TAG"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Latest Release Link
        run: |
          # Create or update a "latest" release that points to the newest nightly
          LATEST_TAG="latest"
          RELEASE_TAG="nightly-${{ steps.get-build.outputs.run_date }}"
          
          cd releases
          
          # Delete existing latest release if it exists
          if gh release view "$LATEST_TAG" >/dev/null 2>&1; then
            gh release delete "$LATEST_TAG" --yes
          fi
          
          # Create latest release pointing to the same files
          gh release create "$LATEST_TAG" \
            --title "Latest Build" \
            --notes "This release always points to the latest successful build.

          **Actual Build Date:** ${{ steps.get-build.outputs.run_date }}  
          **Commit:** ${{ steps.get-build.outputs.run_sha }}  
          
          For the detailed release with individual platform downloads, see: [nightly-${{ steps.get-build.outputs.run_date }}](https://github.com/${{ github.repository }}/releases/tag/nightly-${{ steps.get-build.outputs.run_date }})
          
          $(cat README.md | tail -n +8)" \
            --latest
          
          # Upload the same files to latest
          gh release upload "$LATEST_TAG" *.tar.gz
          
          find . -name "*.exe" -o -name "*.msi" -o -name "*.dmg" -o -name "*.pkg" \
               -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" \
               -o -name "*.ipa" | while read file; do
            if [ -f "$file" ]; then
              gh release upload "$LATEST_TAG" "$file"
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}